# DataBaseConnectivity
Demonstrates the evolution of Java persistence: from raw JDBC to Hibernate ORM, JPA, and Spring Data JPA. Each module shows operations on a common model (e.g., Employee) to illustrate how persistence becomes simpler and more abstract at each stage.


---

## ⚙️ Why These Technologies Were Introduced

| Technology | Purpose | Problem Solved |
|-------------|----------|----------------|
| **JDBC (Java Database Connectivity)** | The first standard API for connecting Java apps to databases | Gave Java a consistent way to execute SQL across all DB vendors |
| **Hibernate** | Simplified object-relational mapping (ORM) | Eliminated repetitive SQL and manual object mapping; introduced automatic transaction and caching support |
| **JPA (Java Persistence API)** | Defined a standard ORM specification for all vendors | Standardized persistence so developers could switch ORM providers easily |
| **Spring Data JPA** | Built on top of JPA to simplify repository patterns | Reduced boilerplate further — introduced derived queries, pagination, and custom method naming conventions |

---

## 🔍 Detailed Overview

### 1️⃣ JDBC
- **Description:**  
  The foundational Java API for database access. You write SQL queries manually and manage `Connection`, `Statement`, and `ResultSet` objects.
  
- **Pros:**
  - Full control over SQL and transactions  
  - No external dependencies  
  - Good for simple or performance-critical operations  

- **Cons:**
  - Verbose and error-prone  
  - No automatic mapping between objects and tables  
  - Hard to maintain and test  

---

### 2️⃣ Hibernate
- **Description:**  
  A full-featured **ORM framework** that automates the conversion between Java objects and database tables. Introduced HQL (Hibernate Query Language).

- **Pros:**
  - Automatic ORM mapping  
  - Built-in caching, transaction, and lazy loading  
  - Reduces SQL boilerplate  

- **Cons:**
  - Learning curve for HQL and mapping annotations  
  - More memory overhead than raw JDBC  
  - Debugging generated SQL can be tricky  

---

### 3️⃣ JPA (Java Persistence API)
- **Description:**  
  A **standard specification** (part of Java EE) defining a uniform ORM API. Hibernate became one of its main implementations.

- **Pros:**
  - Vendor-independent API  
  - Standard annotations (`@Entity`, `@Id`, `@OneToMany`, etc.)  
  - Can switch between implementations (Hibernate, EclipseLink, etc.)  

- **Cons:**
  - Still requires a lot of boilerplate (e.g., `EntityManager` handling)  
  - Learning curve for entity relationships and persistence contexts  

---

### 4️⃣ Spring Data JPA
- **Description:**  
  A high-level abstraction built on top of JPA and Spring. Developers only define **repository interfaces** — implementation is auto-generated by Spring.

- **Pros:**
  - Minimal boilerplate — no `EntityManager` handling  
  - Derived query methods (`findByEmail`, `findByStatusAndDateBetween`, etc.)  
  - Integrated with Spring Boot — transaction and configuration management out of the box  
  - Pagination, sorting, custom queries made easy  

- **Cons:**
  - Less control over generated queries  
  - Might hide performance pitfalls if not tuned  
  - Requires knowledge of JPA under the hood for debugging  

---

## 📊 Comparison Table

| Feature | JDBC | Hibernate | JPA | Spring Data JPA |
|----------|------|-----------|-----|-----------------|
| Abstraction Level | Low | Medium | High | Very High |
| ORM Support | ❌ Manual | ✅ Yes | ✅ Yes | ✅ Yes |
| SQL Handling | Manual | Auto-generated | Auto-generated | Auto-generated |
| Boilerplate Code | Very High | Moderate | Moderate | Very Low |
| Transactions | Manual | Automatic | Automatic | Automatic |
| Vendor Lock-in | None | Vendor-specific | None (standard) | None (standard) |
| Query Language | SQL | HQL | JPQL | JPQL + Derived Queries |
| Best Use Case | Lightweight, performance-critical apps | Complex ORM needs | Standardized ORM | Enterprise, Spring Boot-based apps |

---

## 🧪 Postman Collection

You can test each module’s endpoint using Postman.  
All endpoints accept query parameters — `name` and `department` — to insert or fetch employee data.

| Module | Endpoint URL | Query Parameters |
|---------|---------------|------------------|
| **JDBC** | `http://localhost:8080/jdbc?name=Mayur&department=Comp` | `name=Mayur`, `department=Comp` |
| **Hibernate** | `http://localhost:8080/hibernate?name=Rohit&department=Mech` | `name=Rohit`, `department=Mech` |
| **JPA** | `http://localhost:8080/jpa?name=Rohit&department=Mech` | `name=Rohit`, `department=Mech` |
| **Spring Data JPA** | `http://localhost:8080/springDataJpa?name=Rohit&department=Mech` | `name=Rohit`, `department=Mech` |

### 📦 How to Use
1. Open **Postman** and create a new **GET request**.
2. Use any of the URLs above.
3. Add query parameters:
   - **name** → Employee name  
   - **department** → Department name  
4. Send the request and observe the response from each persistence layer implementation.

> 💡 Each endpoint corresponds to a different persistence technology implementation of the same CRUD operation. This helps visualize how the abstraction and code complexity evolve across JDBC, Hibernate, JPA, and Spring Data JPA.

---
## 🧩 JPA Entity Relationship Mapping

### 📘 Overview
This module demonstrates **how JPA internally handles entity relationships** while creating database associations.

It includes all six major relationship types between entities and shows how **foreign keys** and **join tables** are generated automatically.

### 🧱 Relationships Covered

| Relationship Type | Entities | Annotation Used | Description |
|--------------------|-----------|----------------|--------------|
| **One-to-One (Unidirectional)** | `User` → `UserProfile` | `@OneToOne` | `User` holds the foreign key referencing `UserProfile`. |
| **One-to-One (Bidirectional)** | `Driver` ↔ `Licence` | `@OneToOne(mappedBy = "driver")` | `Licence` owns the relationship; both entities can access each other. |
| **One-to-Many (Unidirectional)** | `School` → `Classroom` | `@OneToMany @JoinColumn(name = "school_id")` | `School` owns the relationship; the foreign key resides in `Classroom`. |
| **One-to-Many (Bidirectional)** | `Author` ↔ `Book` | `@OneToMany(mappedBy = "author")` | `Book` holds the foreign key; `Author` maintains a mapped reference. |
| **Many-to-Many (Unidirectional)** | `Course` → `Student` | `@ManyToMany` | A join table (e.g., `course_student`) connects both entities. |
| **Many-to-Many (Bidirectional)** | `Actor` ↔ `Movie` | `@ManyToMany(mappedBy = "movies")` | A shared join table enables navigation from both sides. |

### 🧠 Internal Mechanics

- **`@OneToOne`** → Adds a foreign key in the owning entity’s table.  
- **`@OneToMany` + `@JoinColumn`** → Adds a foreign key in the child table.  
- **`@ManyToMany`** → Generates an intermediate join table containing both entity IDs.  
- **`mappedBy`** → Indicates the inverse side; JPA does not create another join column for it.

### 🔗 Code Reference
View the implementation here:  
👉 [Entity Relationship Mapping Module](https://github.com/RutwijGhadge/DataBaseConnectivity/tree/main/src/main/java/com/java/EntityRelationShipMapping)

---

## 🏗️ Technologies Used
- Java 17  
- Maven  
- MySQL
- Spring Boot 3.5.6  
- Hibernate ORM  
- JPA API    


