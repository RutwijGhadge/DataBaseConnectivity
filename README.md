# DataBaseConnectivity
Demonstrates the evolution of Java persistence: from raw JDBC to Hibernate ORM, JPA, and Spring Data JPA. Each module shows operations on a common model (e.g., Employee) to illustrate how persistence becomes simpler and more abstract at each stage.


---

## âš™ï¸ Why These Technologies Were Introduced

| Technology | Purpose | Problem Solved |
|-------------|----------|----------------|
| **JDBC (Java Database Connectivity)** | The first standard API for connecting Java apps to databases | Gave Java a consistent way to execute SQL across all DB vendors |
| **Hibernate** | Simplified object-relational mapping (ORM) | Eliminated repetitive SQL and manual object mapping; introduced automatic transaction and caching support |
| **JPA (Java Persistence API)** | Defined a standard ORM specification for all vendors | Standardized persistence so developers could switch ORM providers easily |
| **Spring Data JPA** | Built on top of JPA to simplify repository patterns | Reduced boilerplate further â€” introduced derived queries, pagination, and custom method naming conventions |

---

## ğŸ” Detailed Overview

### 1ï¸âƒ£ JDBC
- **Description:**  
  The foundational Java API for database access. You write SQL queries manually and manage `Connection`, `Statement`, and `ResultSet` objects.
  
- **Pros:**
  - Full control over SQL and transactions  
  - No external dependencies  
  - Good for simple or performance-critical operations  

- **Cons:**
  - Verbose and error-prone  
  - No automatic mapping between objects and tables  
  - Hard to maintain and test  

---

### 2ï¸âƒ£ Hibernate
- **Description:**  
  A full-featured **ORM framework** that automates the conversion between Java objects and database tables. Introduced HQL (Hibernate Query Language).

- **Pros:**
  - Automatic ORM mapping  
  - Built-in caching, transaction, and lazy loading  
  - Reduces SQL boilerplate  

- **Cons:**
  - Learning curve for HQL and mapping annotations  
  - More memory overhead than raw JDBC  
  - Debugging generated SQL can be tricky  

---

### 3ï¸âƒ£ JPA (Java Persistence API)
- **Description:**  
  A **standard specification** (part of Java EE) defining a uniform ORM API. Hibernate became one of its main implementations.

- **Pros:**
  - Vendor-independent API  
  - Standard annotations (`@Entity`, `@Id`, `@OneToMany`, etc.)  
  - Can switch between implementations (Hibernate, EclipseLink, etc.)  

- **Cons:**
  - Still requires a lot of boilerplate (e.g., `EntityManager` handling)  
  - Learning curve for entity relationships and persistence contexts  

---

### 4ï¸âƒ£ Spring Data JPA
- **Description:**  
  A high-level abstraction built on top of JPA and Spring. Developers only define **repository interfaces** â€” implementation is auto-generated by Spring.

- **Pros:**
  - Minimal boilerplate â€” no `EntityManager` handling  
  - Derived query methods (`findByEmail`, `findByStatusAndDateBetween`, etc.)  
  - Integrated with Spring Boot â€” transaction and configuration management out of the box  
  - Pagination, sorting, custom queries made easy  

- **Cons:**
  - Less control over generated queries  
  - Might hide performance pitfalls if not tuned  
  - Requires knowledge of JPA under the hood for debugging  

---

## ğŸ“Š Comparison Table

| Feature | JDBC | Hibernate | JPA | Spring Data JPA |
|----------|------|-----------|-----|-----------------|
| Abstraction Level | Low | Medium | High | Very High |
| ORM Support | âŒ Manual | âœ… Yes | âœ… Yes | âœ… Yes |
| SQL Handling | Manual | Auto-generated | Auto-generated | Auto-generated |
| Boilerplate Code | Very High | Moderate | Moderate | Very Low |
| Transactions | Manual | Automatic | Automatic | Automatic |
| Vendor Lock-in | None | Vendor-specific | None (standard) | None (standard) |
| Query Language | SQL | HQL | JPQL | JPQL + Derived Queries |
| Best Use Case | Lightweight, performance-critical apps | Complex ORM needs | Standardized ORM | Enterprise, Spring Boot-based apps |

---

## ğŸ§ª Postman Collection

You can test each moduleâ€™s endpoint using Postman.  
All endpoints accept query parameters â€” `name` and `department` â€” to insert or fetch employee data.

| Module | Endpoint URL | Query Parameters |
|---------|---------------|------------------|
| **JDBC** | `http://localhost:8080/jdbc?name=Mayur&department=Comp` | `name=Mayur`, `department=Comp` |
| **Hibernate** | `http://localhost:8080/hibernate?name=Rohit&department=Mech` | `name=Rohit`, `department=Mech` |
| **JPA** | `http://localhost:8080/jpa?name=Rohit&department=Mech` | `name=Rohit`, `department=Mech` |
| **Spring Data JPA** | `http://localhost:8080/springDataJpa?name=Rohit&department=Mech` | `name=Rohit`, `department=Mech` |

### ğŸ“¦ How to Use
1. Open **Postman** and create a new **GET request**.
2. Use any of the URLs above.
3. Add query parameters:
   - **name** â†’ Employee name  
   - **department** â†’ Department name  
4. Send the request and observe the response from each persistence layer implementation.

> ğŸ’¡ Each endpoint corresponds to a different persistence technology implementation of the same CRUD operation. This helps visualize how the abstraction and code complexity evolve across JDBC, Hibernate, JPA, and Spring Data JPA.

---
## ğŸ§© JPA Entity Relationship Mapping

### ğŸ“˜ Overview
This module demonstrates **how JPA internally handles entity relationships** while creating database associations.

It includes all six major relationship types between entities and shows how **foreign keys** and **join tables** are generated automatically.

### ğŸ§± Relationships Covered

| Relationship Type | Entities | Annotation Used | Description |
|--------------------|-----------|----------------|--------------|
| **One-to-One (Unidirectional)** | `User` â†’ `UserProfile` | `@OneToOne` | `User` holds the foreign key referencing `UserProfile`. |
| **One-to-One (Bidirectional)** | `Driver` â†” `Licence` | `@OneToOne(mappedBy = "driver")` | `Licence` owns the relationship; both entities can access each other. |
| **One-to-Many (Unidirectional)** | `School` â†’ `Classroom` | `@OneToMany @JoinColumn(name = "school_id")` | `School` owns the relationship; the foreign key resides in `Classroom`. |
| **One-to-Many (Bidirectional)** | `Author` â†” `Book` | `@OneToMany(mappedBy = "author")` | `Book` holds the foreign key; `Author` maintains a mapped reference. |
| **Many-to-Many (Unidirectional)** | `Course` â†’ `Student` | `@ManyToMany` | A join table (e.g., `course_student`) connects both entities. |
| **Many-to-Many (Bidirectional)** | `Actor` â†” `Movie` | `@ManyToMany(mappedBy = "movies")` | A shared join table enables navigation from both sides. |

### ğŸ§  Internal Mechanics

- **`@OneToOne`** â†’ Adds a foreign key in the owning entityâ€™s table.  
- **`@OneToMany` + `@JoinColumn`** â†’ Adds a foreign key in the child table.  
- **`@ManyToMany`** â†’ Generates an intermediate join table containing both entity IDs.  
- **`mappedBy`** â†’ Indicates the inverse side; JPA does not create another join column for it.

### ğŸ”— Code Reference
View the implementation here:  
ğŸ‘‰ [Entity Relationship Mapping Module](https://github.com/RutwijGhadge/DataBaseConnectivity/tree/main/src/main/java/com/java/EntityRelationShipMapping)

---

## ğŸ—ï¸ Technologies Used
- Java 17  
- Maven  
- MySQL
- Spring Boot 3.5.6  
- Hibernate ORM  
- JPA API    


